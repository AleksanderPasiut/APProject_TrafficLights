/*@!Encoding:1250*/
includes
{
  
}

variables
{
  // g³ówny zegar
  msTimer mainTimer;
  
  // zegar pomocniczy
  msTimer auxTimer;
  int anyone_awaiting; // wykrywanie czy ktokolwiek czeka
  
  // sta³e
  const int inputsAmount = 18; // liczba wlotów (przejœcia dla pieszych traktowane jako wloty)
  const int outputsAmount = 4; // liczba wylotów
  const int cyclesAmount = 4; // liczba dostêpnych wariantów cykli
  const int maxCyclePhases = 4; // maksymalna liczba faz w cyklu
  
  // kopie danych z czujników
  double cI[inputsAmount];
  double cF[inputsAmount];
  double cO[outputsAmount];
  
  // macierze cykli
  double B[cyclesAmount][inputsAmount][maxCyclePhases];
  double invB[cyclesAmount][maxCyclePhases][maxCyclePhases];
  
  // zmienne cyklu
  int currentCycle; // identyfikator wybranego cyklu
  int currentPhase; // aktualna faza cyklu
  double x[maxCyclePhases]; // wektor wyjœciowy (czasy poszczególnych faz cyklu)
  
  message RequestSensorsData messege_ReqSensData;

}

on start
{
  currentCycle = 0;
  currentPhase = maxCyclePhases-1;
  anyone_awaiting = IsAnyoneAwaiting();
  PrepareCycles();
  SetTimer(mainTimer, 100);
  
}

on timer mainTimer
{ 
  NooneAwaitingProcessing();
  
  if (anyone_awaiting)
  {
    if (IsAnyoneAwaitingOutsidePhase() || $CyclePhase::time == 0)
      currentPhase = (currentPhase+1) % maxCyclePhases; 
    
    if (currentPhase == 0)
      ChooseBestCycle();  
    
    TranslateCycleToMessage();
    SetTimer(mainTimer, 1000*(int)x[currentPhase]);
   // SetTimer(auxTimer, 200);
    
  }
  else SetTimer(auxTimer, 100);
}

on timer auxTimer
{
  if (IsAnyoneAwaitingInPhase() == 0)
    SetTimer(mainTimer, 0);
  else SetTimer(auxTimer, 200);
}

on message SlaveConnectMaster
{
  if(this.Connect == 1)
    SetTimer(mainTimer,0);
}


int IsAnyoneAwaiting()
{
  int i;
  
  LoadSensorDataKernel();
  
  for (i = 0; i < inputsAmount; i++)
    if (cI[i])
      return 1;
    
  return 0;
}

int IsAnyoneAwaitingInPhase()
{
  int i;
  
  LoadSensorDataKernel();
  
  for (i = 0; i < inputsAmount; i++)
    if (B[currentCycle][i][currentPhase] != 0 && cI[i])
      return 1;
    
  return 0;
}

int IsAnyoneAwaitingOutsidePhase()
{
  int i;
  
  LoadSensorDataKernel();
  
  for (i = 0; i < inputsAmount; i++)
    if (B[currentCycle][i][currentPhase] == 0 && cI[i])
      return 1;
    
  return 0;
}

void PrepareCycles()
{
  // przygotowanie macierzy reprezentuj¹cych cykle
  
  // wyzerowanie wszystkich macierzy
  int i, j, k;
  for (i = 0; i < cyclesAmount; i++)
    for (j = 0; j < inputsAmount; j++)
      for (k = 0; k < maxCyclePhases; k++)
        B[i][j][k] = 0;
  
  // zrównowa¿ony
  B[0][0][0] = B[0][1][0] = B[0][5][0] = B[0][6][0] = B[0][12][0] = B[0][13][0] = B[0][16][0] = B[0][17][0] = 1;
  B[0][2][1] = B[0][7][1] = B[0][11][1] = B[0][15][1] = B[0][12][1] = B[0][16][1] = 1;
  B[0][3][2] = B[0][4][2] = B[0][8][2] = B[0][9][2] = B[0][10][2] = B[0][11][2] = B[0][14][2] = B[0][15][2] = 1;
  B[0][4][3] = B[0][9][3] = B[0][10][3] = B[0][14][3] = 1;
      
  // asymetryczny na g³ównej
  B[1][0][0] = B[1][1][0] = B[1][2][0] = B[1][12][0] = B[1][16][0] = B[1][17][0] = 1;
  B[1][5][1] = B[1][6][1] = B[1][7][1] = B[1][12][1] = B[1][13][1] = B[1][16][1] = 1;
  B[1][3][2] = B[1][4][2] = B[1][8][2] = B[1][9][2] = B[1][10][2] = B[1][11][2] = B[1][14][2] = B[1][15][2] = 1;
  B[1][4][3] = B[1][9][3] = B[1][10][3] = B[1][14][3] = 1;
      
  // asymetryczny na podrzêdnej
  B[2][0][0] = B[2][1][0] = B[2][5][0] = B[2][6][0] = B[2][12][0] = B[2][13][0] = B[2][16][0] = B[2][17][0] = 1;
  B[2][2][1] = B[2][7][1] = B[2][12][1] = B[2][16][1] = 1;
  B[2][3][2] = B[2][4][2] = B[2][10][2] = B[2][11][2] = B[2][13][2] = B[2][14][2] = B[2][16][2] = 1;
  B[2][8][3] = B[2][9][3] = B[2][10][3] = B[2][12][3] = B[2][14][3] = B[2][15][3] = B[2][17][3] = 1;
      
  // asymetryczny zupe³ny
  B[3][0][0] = B[3][1][0] = B[3][2][0] = B[3][11][0] = B[3][12][0] = B[3][14][0] = B[3][16][0] = 1;
  B[3][3][1] = B[3][4][1] = B[3][10][1] = B[3][13][1] = B[3][14][1] = B[3][16][1] = 1;
  B[3][5][2] = B[3][6][2] = B[3][7][2] = B[3][9][2] = B[3][10][2] = B[3][12][2] = B[3][15][2] = B[3][16][2] = 1;
  B[3][8][3] = B[3][9][3] = B[3][10][3] = B[3][12][3] = B[3][14][3] = B[3][17][3] = 1;
  
  for (i = 0; i < cyclesAmount; i++)
    PrepareInversedMatrix(i);
}

void PrepareInversedMatrix(int mat)
{
  // iteratory
  int i, j, k;
  double t;
  
  // dla u³atwienia
  const int m = maxCyclePhases;
  
  // macierz do odwrócenia
  double tmpM[m][m];
  
  // wype³nienie macierzy do odwrócenia
  for (i = 0; i < m; i++)
    for (j = 0; j < m; j++)
    {
      tmpM[i][j] = 0;
      
      for (k = 0; k < inputsAmount; k++)
        tmpM[i][j] += B[mat][k][i]*B[mat][k][j];
    }
  
  // przygotowanie macierzy jednostkowej
  for (i = 0; i < m; i++)
    for (j = 0; j < m; j++)
      invB[mat][i][j] = (i == j ? 1 : 0);
    
  // odwracanie macierzy metod¹ eliminacji Gaussa
  for (i = 0; i+1 < m; i++)
  {
    if (tmpM[i][i] == 0)
      for (j = i+1; j < m; j++)
        if (tmpM[j][i] != 0)
          for (k = 0; k < m; k++)
          {
            t = tmpM[i][k];
            tmpM[i][k] = tmpM[j][k];
            tmpM[j][k] = t;
            t = invB[mat][i][k];
            invB[mat][i][k] = invB[mat][j][k];
            invB[mat][j][k] = t;
          }
          
     if (tmpM[i][i] != 0)
      for (j = i+1; j < m; j++)
      {
        t = tmpM[j][i]/tmpM[i][i];
        
        for (k = i; k < m; k++)
          tmpM[j][k] -= tmpM[i][k]*t;
        
        for (k = 0; k < m; k++)
          invB[mat][j][k] -= invB[mat][i][k]*t;
      }
  }
  
  for (i = m-1; i > 0; i--)
    for (j = 0; j < i; j++)
    {
      t = tmpM[j][i]/tmpM[i][i];
      
      for (k = 0; k < m; k++)
        invB[mat][j][k] -= t*invB[mat][i][k];
    }
    
  for (i = 0; i < m; i++)
    for (j = 0; j < m; j++)
      invB[mat][i][j] /= tmpM[i][i];
}

double Proceed(
  double v[], // wektor natê¿eñ ruchu
  int mat,  // identyfikator sprawdzanej macierzy
  double x[],
  double x_min,
  double x_max,
  double Tc)
{
  // iteratory
  int i, j, k;
  
  // skrócone nazwy dla u³atwienia
  const int n = inputsAmount;
  const int m = cyclesAmount;
  
  double tmp = 0.0;
  double s = 0.0;
  double deltaV;
  
  double vector[m];
  double dv[n];
  
  // przygotowanie wektora wspó³czynników
  for (i = 0; i < m; i++)
  {
    vector[i] = 0;
    
    for (j = 0; j < n; j++)
      vector[i] += B[mat][j][i]*v[j];
  }
  
  // x = invB*vector
  for (i = 0; i < m; i++)
  {
    x[i] = 0;
    
    for (j = 0; j < m; j++)
      x[i] += invB[mat][i][j]*vector[j];
  }
  
  // obliczenie sta³ej s
  tmp = 0.0;
  for (i = 0; i < m; i++)
    tmp += x[i];
  
  if (tmp != 0)
    s = Tc/tmp;
  
  // przeskalowanie wektora i uwzglêdnienie ograniczeñ
  for (i = 0; i < m; i++)
  {
    x[i] *= s;
    
    if (x[i] < x_min)
      x[i] = x_min;
    if (x[i] > x_max)
      x[i] = x_max;
  }
  
  // obliczenie b³êdu
  for (i = 0; i < n; i++)
  {
    dv[i] = 0;
    
    for (j = 0; j < m; j++)
      dv[i] += B[mat][i][j]*x[j];
    
    dv[i] -= v[i]*s;
  }
  deltaV = 0;
  for (i = 0; i < n; i++)
    deltaV += dv[i]*dv[i];
 
  return sqrt(deltaV);
}

double max(double a, double b)
{
  return a >= b ? a : b;
}

void LoadSensorDataKernel()
{
  $RequestSensorsData::OK = 1;
  //output(messege_ReqSensData);
//  cO[0] = !getValue(Check_Output0);
//  cO[1] = !getValue(Check_Output1);
//  cO[2] = !getValue(Check_Output2);
//  cO[3] = !getValue(Check_Output3);
//  
//  cI[0] = getValue(Check_Input0) && cO[2] && cO[3];
//  cI[1] = getValue(Check_Input1) && cO[2];
//  cI[2] = getValue(Check_Input2) && cO[1];
//  cI[3] = getValue(Check_Input3) && cO[0] && cO[3];
//  cI[4] = getValue(Check_Input4) && cO[2] && cO[3];
//  cI[5] = getValue(Check_Input5) && cO[0] && cO[1];
//  cI[6] = getValue(Check_Input6) && cO[0];
//  cI[7] = getValue(Check_Input7) && cO[3];
//  cI[8] = getValue(Check_Input8) && cO[1] && cO[2];
//  cI[9] = getValue(Check_Input9) && cO[0] && cO[1];
//  cI[10] = getValue(Check_Input10);
//  cI[11] = getValue(Check_Input11);
//  cI[12] = getValue(Check_Input12);
//  cI[13] = getValue(Check_Input13);
//  cI[14] = getValue(Check_Input14);
//  cI[15] = getValue(Check_Input15);
//  cI[16] = getValue(Check_Input16);
//  cI[17] = getValue(Check_Input17);
//  
//  cF[0] = getValue(Frequency0);
//  cF[1] = getValue(Frequency1);
//  cF[2] = getValue(Frequency2);
//  cF[3] = getValue(Frequency3);
//  cF[4] = getValue(Frequency4);
//  cF[5] = getValue(Frequency5);
//  cF[6] = getValue(Frequency6);
//  cF[7] = getValue(Frequency7);
//  cF[8] = getValue(Frequency8);
//  cF[9] = getValue(Frequency9);
//  cF[10] = getValue(Frequency10);
//  cF[11] = getValue(Frequency11);
//  cF[12] = getValue(Frequency12);
//  cF[13] = getValue(Frequency13);
//  cF[14] = getValue(Frequency14);
//  cF[15] = getValue(Frequency15);
//  cF[16] = getValue(Frequency16);
//  cF[17] = getValue(Frequency17);
}

on message SensorsData 
{
  Write("Data From Sensors");  
  
  cO[0] = $SensorsData::C_Output0;
  cO[1] = $SensorsData::C_Output1;
  cO[2] = $SensorsData::C_Output2;
  cO[3] = $SensorsData::C_Output3;
  
  cI[0] = $SensorsData::C_Input0 && cO[2] && cO[3];
  cI[1] = $SensorsData::C_Input1 && cO[2];
  cI[2] = $SensorsData::C_Input2 && cO[1];
  cI[3] = $SensorsData::C_Input3 && cO[0] && cO[3];
  cI[4] = $SensorsData::C_Input4 && cO[2] && cO[3];
  cI[5] = $SensorsData::C_Input5 && cO[0] && cO[1];
  cI[6] = $SensorsData::C_Input6 && cO[0];
  cI[7] = $SensorsData::C_Input7 && cO[3];
  cI[8] = $SensorsData::C_Input8 && cO[1] && cO[2];
  cI[9] = $SensorsData::C_Input9 && cO[0] && cO[1];
  cI[10] = $SensorsData::C_Input10;
  cI[11] = $SensorsData::C_Input11;
  cI[12] = $SensorsData::C_Input12;
  cI[13] = $SensorsData::C_Input13;
  cI[14] = $SensorsData::C_Input14;
  cI[15] = $SensorsData::C_Input15;
  cI[16] = $SensorsData::C_Input16;
  cI[17] = $SensorsData::C_Input17;
  
  cF[0] = $SensorsData::C_Frequency0;
  cF[1] = $SensorsData::C_Frequency1;
  cF[2] = $SensorsData::C_Frequency2;
  cF[3] = $SensorsData::C_Frequency3;
  cF[4] = $SensorsData::C_Frequency4;
  cF[5] = $SensorsData::C_Frequency5;
  cF[6] = $SensorsData::C_Frequency6;
  cF[7] = $SensorsData::C_Frequency7;
  cF[8] = $SensorsData::C_Frequency8;
  cF[9] = $SensorsData::C_Frequency9;
  cF[10] = $SensorsData::C_Frequency10;
  cF[11] = $SensorsData::C_Frequency11;
  cF[12] = $SensorsData::C_Frequency12;
  cF[13] = $SensorsData::C_Frequency13;
  cF[14] = $SensorsData::C_Frequency14;
  cF[15] = $SensorsData::C_Frequency15;
  cF[16] = $SensorsData::C_Frequency16;
  cF[17] = $SensorsData::C_Frequency17;
}

void LoadSensorData(double v[])
{   
  int i;
  
  double vm = 2.0;
  
  LoadSensorDataKernel();

  for (i = 0; i < inputsAmount; i++)
    v[i] = cI[i] ? max(vm, cF[i]) : 0;
}

void ChooseBestCycle()
{
  int i, j, k;
  double tmp;
  
  double Tc; // czas ca³kowity cyklu
  double Tp; // czas ¿ó³tego œwiat³a
  double x_min; // minimalny czas zielonego œwiat³a
  double x_max; // maksymalny czas zielonego œwiat³a
  double deltaV = 10000000; // niedok³adnoœæ
  double v[inputsAmount]; // wektor natê¿eñ ruchu
  
  Tc = getValue(Tcycle);
  x_min = getValue(Tmin);
  x_max = getValue(Tmax);
  
  LoadSensorData(v);
  
  currentCycle = 0;
  
  for (i = 0; i < cyclesAmount; i++)
  {
    tmp = Proceed(v, i, x, x_min, x_max, Tc);
    
    if (deltaV > tmp)
    {
      deltaV = tmp;
      currentCycle = i;
    }
  }
  
  deltaV = Proceed(v, currentCycle, x, x_min, x_max, Tc);
  
  Write("Choosing best cycle: %d", currentCycle);
  Write("%lf %lf %lf %lf", x[0], x[1], x[2], x[3]);
}

void TranslateCycleToMessage()
{ 
  int i;
  
  $CyclePhase::time = x[currentPhase];
  $CyclePhase::input0 = (int)B[currentCycle][0][currentPhase] && cI[0];
  $CyclePhase::input1 = (int)B[currentCycle][1][currentPhase] && cI[1];
  $CyclePhase::input2 = (int)B[currentCycle][2][currentPhase] && cI[2];
  $CyclePhase::input3 = (int)B[currentCycle][3][currentPhase] && cI[3];
  $CyclePhase::input4 = (int)B[currentCycle][4][currentPhase] && cI[4];
  $CyclePhase::input5 = (int)B[currentCycle][5][currentPhase] && cI[5];
  $CyclePhase::input6 = (int)B[currentCycle][6][currentPhase] && cI[6];
  $CyclePhase::input7 = (int)B[currentCycle][7][currentPhase] && cI[7];
  $CyclePhase::input8 = (int)B[currentCycle][8][currentPhase] && cI[8];
  $CyclePhase::input9 = (int)B[currentCycle][9][currentPhase] && cI[9];
  $CyclePhase::input10 = (int)B[currentCycle][10][currentPhase] && cI[10];
  $CyclePhase::input11 = (int)B[currentCycle][11][currentPhase] && cI[11];
  $CyclePhase::input12 = (int)B[currentCycle][12][currentPhase] && cI[12];
  $CyclePhase::input13 = (int)B[currentCycle][13][currentPhase] && cI[13];
  $CyclePhase::input14 = (int)B[currentCycle][14][currentPhase] && cI[14];
  $CyclePhase::input15 = (int)B[currentCycle][15][currentPhase] && cI[15];
  $CyclePhase::input16 = (int)B[currentCycle][16][currentPhase] && cI[16];
  $CyclePhase::input17 = (int)B[currentCycle][17][currentPhase] && cI[17];
  
  Write("Cycle activated: %d", currentCycle);
}

void NooneAwaitingProcessing()
{
  if (IsAnyoneAwaiting() == 0)
  {
    if (anyone_awaiting == 1)
    {
      anyone_awaiting = 0;
      SetRedLights();
      SetTimer(mainTimer, 100);
      SetTimer(auxTimer, 1000);
    }
  }
  else anyone_awaiting = 1;
}

void SetRedLights()
{
  $CyclePhase::time = 0;
  $CyclePhase::input0 = 0;
  $CyclePhase::input1 = 0;
  $CyclePhase::input2 = 0;
  $CyclePhase::input3 = 0;
  $CyclePhase::input4 = 0;
  $CyclePhase::input5 = 0;
  $CyclePhase::input6 = 0;
  $CyclePhase::input7 = 0;
  $CyclePhase::input8 = 0;
  $CyclePhase::input9 = 0;
  $CyclePhase::input10 = 0;
  $CyclePhase::input11 = 0;
  $CyclePhase::input12 = 0;
  $CyclePhase::input13 = 0;
  $CyclePhase::input14 = 0;
  $CyclePhase::input15 = 0;
  $CyclePhase::input16 = 0;
  $CyclePhase::input17 = 0;
  
  Write("No incoming traffic.");
}
