/*@!Encoding:1250*/
includes
{
  
}

variables
{  
  // sta³e
  const int inputsAmount = 18; // liczba wlotów (przejœcia dla pieszych traktowane jako wloty)
  const int outputsAmount = 4; // liczba wylotów
  const int cyclesAmount = 4; // liczba dostêpnych wariantów cykli
  const int cyclePhases = 4; // liczba faz w cyklu
  
  // kopie danych z czujników
  int cI[inputsAmount];
  int cO[outputsAmount];
  
  // macierze cykli
  double B[cyclesAmount][inputsAmount][cyclePhases];
  double invB[cyclesAmount][cyclePhases][cyclePhases];
  
  // zmienne cyklu
  int currentCycle; // identyfikator wybranego cyklu
  int currentPhase; // aktualna faza cyklu
  double x[cyclePhases]; // wektor wyjœciowy (czasy poszczególnych faz cyklu)
  
  message RequestSensorsData messege_ReqSensData;
}

double max(double a, double b)
{
  return a >= b ? a : b;
}

on start
{
  currentCycle = 0;
  currentPhase = cyclePhases-1;
  
  PrepareCycles();
}

void PrepareCycles()
{
  // przygotowanie macierzy reprezentuj¹cych cykle
  
  // wyzerowanie wszystkich macierzy
  int i, j, k;
  for (i = 0; i < cyclesAmount; i++)
    for (j = 0; j < inputsAmount; j++)
      for (k = 0; k < cyclePhases; k++)
        B[i][j][k] = 0;
  
  // zrównowa¿ony
  B[0][0][0] = B[0][1][0] = B[0][5][0] = B[0][6][0] = B[0][12][0] = B[0][13][0] = B[0][16][0] = B[0][17][0] = 1;
  B[0][2][1] = B[0][7][1] = B[0][11][1] = B[0][15][1] = B[0][12][1] = B[0][16][1] = 1;
  B[0][3][2] = B[0][4][2] = B[0][8][2] = B[0][9][2] = B[0][10][2] = B[0][11][2] = B[0][14][2] = B[0][15][2] = 1;
  B[0][4][3] = B[0][9][3] = B[0][10][3] = B[0][14][3] = 1;
      
  // asymetryczny na g³ównej
  B[1][0][0] = B[1][1][0] = B[1][2][0] = B[1][12][0] = B[1][16][0] = B[1][17][0] = 1;
  B[1][5][1] = B[1][6][1] = B[1][7][1] = B[1][12][1] = B[1][13][1] = B[1][16][1] = 1;
  B[1][3][2] = B[1][4][2] = B[1][8][2] = B[1][9][2] = B[1][10][2] = B[1][11][2] = B[1][14][2] = B[1][15][2] = 1;
  B[1][4][3] = B[1][9][3] = B[1][10][3] = B[1][14][3] = 1;
      
  // asymetryczny na podrzêdnej
  B[2][0][0] = B[2][1][0] = B[2][5][0] = B[2][6][0] = B[2][12][0] = B[2][13][0] = B[2][16][0] = B[2][17][0] = 1;
  B[2][2][1] = B[2][7][1] = B[2][12][1] = B[2][16][1] = 1;
  B[2][3][2] = B[2][4][2] = B[2][10][2] = B[2][11][2] = B[2][13][2] = B[2][14][2] = B[2][16][2] = 1;
  B[2][8][3] = B[2][9][3] = B[2][10][3] = B[2][12][3] = B[2][14][3] = B[2][15][3] = B[2][17][3] = 1;
      
  // asymetryczny zupe³ny
  B[3][0][0] = B[3][1][0] = B[3][2][0] = B[3][11][0] = B[3][12][0] = B[3][14][0] = B[3][16][0] = 1;
  B[3][3][1] = B[3][4][1] = B[3][10][1] = B[3][13][1] = B[3][14][1] = B[3][16][1] = 1;
  B[3][5][2] = B[3][6][2] = B[3][7][2] = B[3][9][2] = B[3][10][2] = B[3][12][2] = B[3][15][2] = B[3][16][2] = 1;
  B[3][8][3] = B[3][9][3] = B[3][10][3] = B[3][12][3] = B[3][14][3] = B[3][17][3] = 1;
  
  for (i = 0; i < cyclesAmount; i++)
    PrepareInversedMatrix(i);
}

void PrepareInversedMatrix(int mat)
{
  // iteratory
  int i, j, k;
  double t;
  
  // dla u³atwienia
  const int m = cyclePhases;
  
  // macierz do odwrócenia
  double tmpM[m][m];
  
  // wype³nienie macierzy do odwrócenia
  for (i = 0; i < m; i++)
    for (j = 0; j < m; j++)
    {
      tmpM[i][j] = 0;
      
      for (k = 0; k < inputsAmount; k++)
        tmpM[i][j] += B[mat][k][i]*B[mat][k][j];
    }
  
  // przygotowanie macierzy jednostkowej
  for (i = 0; i < m; i++)
    for (j = 0; j < m; j++)
      invB[mat][i][j] = (i == j ? 1 : 0);
    
  // odwracanie macierzy metod¹ eliminacji Gaussa
  for (i = 0; i+1 < m; i++)
  {
    if (tmpM[i][i] == 0)
      for (j = i+1; j < m; j++)
        if (tmpM[j][i] != 0)
          for (k = 0; k < m; k++)
          {
            t = tmpM[i][k];
            tmpM[i][k] = tmpM[j][k];
            tmpM[j][k] = t;
            t = invB[mat][i][k];
            invB[mat][i][k] = invB[mat][j][k];
            invB[mat][j][k] = t;
          }
          
     if (tmpM[i][i] != 0)
      for (j = i+1; j < m; j++)
      {
        t = tmpM[j][i]/tmpM[i][i];
        
        for (k = i; k < m; k++)
          tmpM[j][k] -= tmpM[i][k]*t;
        
        for (k = 0; k < m; k++)
          invB[mat][j][k] -= invB[mat][i][k]*t;
      }
  }
  
  for (i = m-1; i > 0; i--)
    for (j = 0; j < i; j++)
    {
      t = tmpM[j][i]/tmpM[i][i];
      
      for (k = 0; k < m; k++)
        invB[mat][j][k] -= t*invB[mat][i][k];
    }
    
  for (i = 0; i < m; i++)
    for (j = 0; j < m; j++)
      invB[mat][i][j] /= tmpM[i][i];
}

on key*
{
  if (IsAnyoneAwaiting())
  {
    currentPhase = (currentPhase+1) % cyclePhases;
  
    if (currentPhase == 0)
      ChooseBestCycle();
    
    TranslateCycleToMessage();
  }
  else
  {
    currentPhase = 0;
    $CyclePhase::time = 0;
    SetRedLights();
  }
}

int IsAnyoneAwaiting()
{
  int i;
  
  LoadSensorDataKernel();
  
  for (i = 0; i < inputsAmount; i++)
    if (cI[i])
      return 1;
    
  return 0;
}

void LoadSensorDataKernel()
{
  $RequestSensorsData::OK = 1;
}

on message SensorsDataOutputs
{  
  cO[0] = $SensorsDataOutputs::C_Output0;
  cO[1] = $SensorsDataOutputs::C_Output1;
  cO[2] = $SensorsDataOutputs::C_Output2;
  cO[3] = $SensorsDataOutputs::C_Output3;
}

on message SensorsDataCars
{
  cI[0] = (cO[2] && cO[3])  ? $SensorsDataCars::C_Input00 : 0;
  cI[1] = cO[2]             ? $SensorsDataCars::C_Input01 : 0;
  cI[2] = cO[1]             ? $SensorsDataCars::C_Input02 : 0;
  cI[3] = (cO[0] && cO[3])  ? $SensorsDataCars::C_Input03 : 0;
  cI[4] = (cO[2] && cO[3])  ? $SensorsDataCars::C_Input04 : 0;
  cI[5] = (cO[0] && cO[1])  ? $SensorsDataCars::C_Input05 : 0;
  cI[6] = cO[0]             ? $SensorsDataCars::C_Input06 : 0;
  cI[7] = cO[3]             ? $SensorsDataCars::C_Input07 : 0;
  cI[8] = (cO[1] && cO[2])  ? $SensorsDataCars::C_Input08 : 0;
  cI[9] = (cO[0] && cO[1])  ? $SensorsDataCars::C_Input09 : 0;
}

on message SensorsDataWalkers
{
  cI[10] = $SensorsDataWalkers::C_Input10;
  cI[11] = $SensorsDataWalkers::C_Input11;
  cI[12] = $SensorsDataWalkers::C_Input12;
  cI[13] = $SensorsDataWalkers::C_Input13;
  cI[14] = $SensorsDataWalkers::C_Input14;
  cI[15] = $SensorsDataWalkers::C_Input15;
  cI[16] = $SensorsDataWalkers::C_Input16;
  cI[17] = $SensorsDataWalkers::C_Input17;
}

void ChooseBestCycle()
{
  int i, j, k;
  double tmp;
  
  double Tc; // czas ca³kowity cyklu
  double Tp; // czas ¿ó³tego œwiat³a
  double x_min; // minimalny czas zielonego œwiat³a
  double x_max; // maksymalny czas zielonego œwiat³a
  double deltaV = 10000000; // niedok³adnoœæ
  double v[inputsAmount]; // wektor wspó³czynników
  
  Tc = getValue(Tcycle);
  Tp = getValue(Tyellow);
  x_min = getValue(Tmin);
  x_max = getValue(Tmax);
  
  for (i = 0; i < inputsAmount; i++)
    v[i] = (double)cI[i];
  
  currentCycle = 0;
  
  for (i = 0; i < cyclesAmount; i++)
  {
    tmp = Proceed(v, i, x, x_min, x_max, Tc, Tp);
    
    if (deltaV > tmp)
    {
      deltaV = tmp;
      currentCycle = i;
    }
  }
  
  deltaV = Proceed(v, currentCycle, x, x_min, x_max, Tc, Tp);
  
  Write("Choosing best cycle: %d", currentCycle);
  Write("%lf %lf %lf %lf", x[0], x[1], x[2], x[3]);
}

double Proceed(
  double v[], // wektor natê¿eñ ruchu
  int mat,  // identyfikator sprawdzanej macierzy
  double x[],
  double x_min,
  double x_max,
  double Tc,
  double Tp)
{
  // iteratory
  int i, j, k;
  
  // skrócone nazwy dla u³atwienia
  const int n = inputsAmount;
  const int m = cyclesAmount;
  
  double tmp = 0.0;
  double s = 0.0;
  double deltaV;
  
  double vector[m];
  double dv[n];
  
  // przygotowanie wektora wspó³czynników
  for (i = 0; i < m; i++)
  {
    vector[i] = 0;
    
    for (j = 0; j < n; j++)
      vector[i] += B[mat][j][i]*v[j];
  }
  
  // x = invB*vector
  for (i = 0; i < m; i++)
  {
    x[i] = 0;
    
    for (j = 0; j < m; j++)
      x[i] += invB[mat][i][j]*vector[j];
  }
  
  // obliczenie czasu trwania cyklu
  s = 0;
  for (j = 0; j < 4; j++)
  {
    tmp = 0;
    for (i = 0; i < 10; i++)
      if (tmp < B[mat][i][j]*2.15*v[i])
          tmp = B[mat][i][j]*2.15*v[i];
      
      s += tmp;
  }
  
  if (Tc > s+4*Tp)
      Tc = s+4*Tp;
  
  // obliczenie sta³ej s
  tmp = 0.0;
  for (i = 0; i < m; i++)
    tmp += x[i];
  
  if (tmp != 0)
    s = (Tc-4*Tp)/tmp;
  
  // przeskalowanie wektora i uwzglêdnienie ograniczeñ
  for (i = 0; i < m; i++)
  {
    x[i] *= s;
    
    if (x[i] < x_min)
      x[i] = x_min;
    if (x[i] > x_max)
      x[i] = x_max;
  }
  
  // obliczenie b³êdu
  for (i = 0; i < n; i++)
  {
    dv[i] = 0;
    
    for (j = 0; j < m; j++)
      dv[i] += B[mat][i][j]*x[j];
    
    dv[i] -= v[i]*s;
  }
  deltaV = 0;
  for (i = 0; i < n; i++)
    deltaV += dv[i]*dv[i];
 
  return sqrt(deltaV);
}

void TranslateCycleToMessage()
{ 
  int i;
  
  $CyclePhase::time = x[currentPhase];
  $CyclePhase::input0 = (int)B[currentCycle][0][currentPhase] && cI[0];
  $CyclePhase::input1 = (int)B[currentCycle][1][currentPhase] && cI[1];
  $CyclePhase::input2 = (int)B[currentCycle][2][currentPhase] && cI[2];
  $CyclePhase::input3 = (int)B[currentCycle][3][currentPhase] && cI[3];
  $CyclePhase::input4 = (int)B[currentCycle][4][currentPhase] && cI[4];
  $CyclePhase::input5 = (int)B[currentCycle][5][currentPhase] && cI[5];
  $CyclePhase::input6 = (int)B[currentCycle][6][currentPhase] && cI[6];
  $CyclePhase::input7 = (int)B[currentCycle][7][currentPhase] && cI[7];
  $CyclePhase::input8 = (int)B[currentCycle][8][currentPhase] && cI[8];
  $CyclePhase::input9 = (int)B[currentCycle][9][currentPhase] && cI[9];
  $CyclePhase::input10 = (int)B[currentCycle][10][currentPhase] && cI[10];
  $CyclePhase::input11 = (int)B[currentCycle][11][currentPhase] && cI[11];
  $CyclePhase::input12 = (int)B[currentCycle][12][currentPhase] && cI[12];
  $CyclePhase::input13 = (int)B[currentCycle][13][currentPhase] && cI[13];
  $CyclePhase::input14 = (int)B[currentCycle][14][currentPhase] && cI[14];
  $CyclePhase::input15 = (int)B[currentCycle][15][currentPhase] && cI[15];
  $CyclePhase::input16 = (int)B[currentCycle][16][currentPhase] && cI[16];
  $CyclePhase::input17 = (int)B[currentCycle][17][currentPhase] && cI[17];
  
  //Right Arrows - 0,3,5,8
  $CyclePhase::input18 = (int)B[currentCycle][0][currentPhase] && cI[0] &&(int)B[currentCycle][7][currentPhase] && cI[7];;
  $CyclePhase::input19 = (int)B[currentCycle][3][currentPhase] && cI[3];
  $CyclePhase::input20 = (int)B[currentCycle][2][currentPhase] && cI[2] && (int)B[currentCycle][5][currentPhase] && cI[5];
  $CyclePhase::input21 = (int)B[currentCycle][8][currentPhase] && cI[8];
    
  Write("Cycle activated: %d", currentCycle);
}


void SetRedLights()
{
  Write("No incoming traffic.");
  $CyclePhase::time = 0;
  $CyclePhase::input0 = 0;
  $CyclePhase::input1 = 0;
  $CyclePhase::input2 = 0;
  $CyclePhase::input3 = 0;
  $CyclePhase::input4 = 0;
  $CyclePhase::input5 = 0;
  $CyclePhase::input6 = 0;
  $CyclePhase::input7 = 0;
  $CyclePhase::input8 = 0;
  $CyclePhase::input9 = 0;
  $CyclePhase::input10 = 0;
  $CyclePhase::input11 = 0;
  $CyclePhase::input12 = 0;
  $CyclePhase::input13 = 0;
  $CyclePhase::input14 = 0;
  $CyclePhase::input15 = 0;
  $CyclePhase::input16 = 0;
  $CyclePhase::input17 = 0;
  
  $CyclePhase::input18 = 0;
  $CyclePhase::input19 = 0;
  $CyclePhase::input20 = 0;
  $CyclePhase::input21 = 0;
}
